<!-- 
     For more details about configurations options that may appear in
     this file, see http://wiki.apache.org/solr/SolrConfigXml.
 -->
<config>
	<!--  In all configuration below, a prefix of "solr." for class names
       is an alias that causes solr to search appropriate packages,
       including org.apache.solr.(search|update|request|core|analysis)

       You may also specify a fully qualified Java classname if you
       have your own custom plugins.
     -->
	<!--  Controls what version of Lucene various components of Solr
       adhere to.  Generally, you want to use the latest version to
       get all bug fixes and improvements. It is highly recommended
       that you fully re-index after changing this setting as it can
       affect both how text is indexed and queried.
   -->
	<luceneMatchVersion>8.8.2</luceneMatchVersion>
	<!--  <lib/> directives can be used to instruct Solr to load any Jars
       identified and use them to resolve any "plugins" specified in
       your solrconfig.xml or schema.xml (ie: Analyzers, Request
       Handlers, etc...).
	   If a "./lib" directory exists in your instanceDir, all files
       found in it are included as if you had used the following
       syntax...

              <lib dir="./lib" / -->
	<!--  Data Directory

       Used to specify an alternate directory to hold all index data
       other than the default ./data under the Solr home.  If
       replication is in use, this should match the replication
       configuration. -->
	<dataDir>${solr.data.dir:C:/MY_FILES/SOFTWARES/MY_SOLR_COLLECTIONS_AND_SCHEMA/address_collection/data}</dataDir>
	<!--  The DirectoryFactory to use for indexes.

       solr.StandardDirectoryFactory is filesystem
       based and tries to pick the best implementation for the current
       JVM and platform.  solr.NRTCachingDirectoryFactory, the default,
       wraps solr.StandardDirectoryFactory and caches small files in memory
       for better NRT performance.

       One can force a particular implementation via solr.MMapDirectoryFactory,
       solr.NIOFSDirectoryFactory, or solr.SimpleFSDirectoryFactory.

       solr.RAMDirectoryFactory is memory based and not persistent.
     -->
	<directoryFactory name="DirectoryFactory" class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}"/>
	<!--  The CodecFactory for defining the format of the inverted index.
       The default implementation is SchemaCodecFactory, which is the official Lucene
       index format, but hooks into the schema to provide per-field customization of
       the postings lists and per-document values in the fieldType element
       (postingsFormat/docValuesFormat). Note that most of the alternative implementations
       are experimental, so if you choose to customize the index format, it's a good
       idea to convert back to the official format e.g. via IndexWriter.addIndexes(IndexReader)
       before upgrading to a newer version to avoid unnecessary reindexing.
       A "compressionMode" string element can be added to <codecFactory> to choose
       between the existing compression modes in the default codec: "BEST_SPEED" (default)
       or "BEST_COMPRESSION".
   -->
	<codecFactory class="solr.SchemaCodecFactory"/>
	<!-- Below has been added incontrast to use Static Schema and avoid default Managed Schema -->
	<schemaFactory class="ClassicIndexSchemaFactory"/>
	<!--  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       Index Config - These settings control low-level behavior of indexing
       Most example settings here show the default value, but are commented
       out, to more easily see where customizations have been made.

       Note: This replaces <indexDefaults> and <mainIndex> from older versions
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -->
	<indexConfig>
		<!--  maxFieldLength was removed in 4.0. To get similar behavior, include a
         LimitTokenCountFilterFactory in your fieldType definition. E.g.
     <filter class="solr.LimitTokenCountFilterFactory" maxTokenCount="10000"/>
     -->
		<!--  Maximum time to wait for a write lock (ms) for an IndexWriter. Default: 1000  -->
		<!--  <writeLockTimeout>1000</writeLockTimeout>   -->
		<!--  Expert: Enabling compound file will use less files for the index,
         using fewer file descriptors on the expense of performance decrease.
         Default in Lucene is "true". Default in Solr is "false" (since 3.6)  -->
		<!--  <useCompoundFile>false</useCompoundFile>  -->
		<!--  ramBufferSizeMB sets the amount of RAM that may be used by Lucene
         indexing for buffering added documents and deletions before they are
         flushed to the Directory.
         maxBufferedDocs sets a limit on the number of documents buffered
         before flushing.
         If both ramBufferSizeMB and maxBufferedDocs is set, then
         Lucene will flush based on whichever limit is hit first.
         The default is 100 MB.   -->
		<!--  <ramBufferSizeMB>100</ramBufferSizeMB>  -->
		<!--  <maxBufferedDocs>1000</maxBufferedDocs>  -->
		<!--  Expert: ramPerThreadHardLimitMB sets the maximum amount of RAM that can be consumed
         per thread before they are flushed. When limit is exceeded, this triggers a forced
         flush even if ramBufferSizeMB has not been exceeded.
         This is a safety limit to prevent Lucene's DocumentsWriterPerThread from address space
         exhaustion due to its internal 32 bit signed integer based memory addressing.
         The specified value should be greater than 0 and less than 2048MB. When not specified,
         Solr uses Lucene's default value 1945.  -->
		<!--  <ramPerThreadHardLimitMB>1945</ramPerThreadHardLimitMB>  -->
		<!--  Expert: Merge Policy
         The Merge Policy in Lucene controls how merging of segments is done.
         The default since Solr/Lucene 3.3 is TieredMergePolicy.
         The default since Lucene 2.3 was the LogByteSizeMergePolicy,
         Even older versions of Lucene used LogDocMergePolicy.
       -->
		<!-- 
        <mergePolicyFactory class="org.apache.solr.index.TieredMergePolicyFactory">
          <int name="maxMergeAtOnce">10</int>
          <int name="segmentsPerTier">10</int>
          <double name="noCFSRatio">0.1</double>
        </mergePolicyFactory>
       -->
		<!--  Expert: Merge Scheduler
         The Merge Scheduler in Lucene controls how merges are
         performed.  The ConcurrentMergeScheduler (Lucene 2.3 default)
         can perform merges in the background using separate threads.
         The SerialMergeScheduler (Lucene 2.2 default) does not.
      -->
		<!-- 
       <mergeScheduler class="org.apache.lucene.index.ConcurrentMergeScheduler"/>
        -->
		<!--  LockFactory

         This option specifies which Lucene LockFactory implementation
         to use.

         single = SingleInstanceLockFactory - suggested for a
                  read-only index or when there is no possibility of
                  another process trying to modify the index.
         native = NativeFSLockFactory - uses OS native file locking.
                  Do not use when multiple solr webapps in the same
                  JVM are attempting to share a single index.
         simple = SimpleFSLockFactory  - uses a plain file for locking

         Defaults: 'native' is default for Solr3.6 and later, otherwise
                   'simple' is the default

         More details on the nuances of each LockFactory...
         http://wiki.apache.org/lucene-java/AvailableLockFactories
     -->
		<lockType>${solr.lock.type:native}</lockType>
		<!--  Commit Deletion Policy
         Custom deletion policies can be specified here. The class must
         implement org.apache.lucene.index.IndexDeletionPolicy.

         The default Solr IndexDeletionPolicy implementation supports
         deleting index commit points on number of commits, age of
         commit point and optimized status.

         The latest commit point should always be preserved regardless
         of the criteria.
     -->
		<!-- 
    <deletionPolicy class="solr.SolrDeletionPolicy">
     -->
		<!--  The number of commit points to be kept  -->
		<!--  <str name="maxCommitsToKeep">1</str>  -->
		<!--  The number of optimized commit points to be kept  -->
		<!--  <str name="maxOptimizedCommitsToKeep">0</str>  -->
		<!-- 
          Delete all commit points once they have reached the given age.
          Supports DateMathParser syntax e.g.
         -->
		<!-- 
         <str name="maxCommitAge">30MINUTES</str>
         <str name="maxCommitAge">1DAY</str>
       -->
		<!-- 
    </deletionPolicy>
     -->
		<!--  Lucene Infostream

         To aid in advanced debugging, Lucene provides an "InfoStream"
         of detailed information when indexing.

         Setting the value to true will instruct the underlying Lucene
         IndexWriter to write its info stream to solr's log. By default,
         this is enabled here, and controlled through log4j2.xml
       -->
		<infoStream>true</infoStream>
	</indexConfig>
	<!--  JMX

       This example enables JMX if and only if an existing MBeanServer
       is found, use this if you want to configure JMX through JVM
       parameters. Remove this to disable exposing Solr configuration
       and statistics to JMX.

       For more details see http://wiki.apache.org/solr/SolrJmx
     -->
	<jmx/>
	<!--  Request Handlers

       http://wiki.apache.org/solr/SolrRequestHandler

       Incoming queries will be dispatched to a specific handler by name
       based on the path specified in the request.

       If a Request Handler is declared with startup="lazy", then it will
       not be initialized until the first request that uses it.

     -->
	<!--  SearchHandler

       http://wiki.apache.org/solr/SearchHandler

       For processing Search Queries, the primary Request Handler
       provided with Solr is "SearchHandler" It delegates to a sequent
       of SearchComponents (see below) and supports distributed
       queries across multiple shards
     -->
	<requestHandler name="/select" class="solr.SearchHandler">
		<!--  default values for query parameters can be specified, these
         will be overridden by parameters in the request
       -->
		<lst name="defaults">
			<str name="echoParams">explicit</str>
			<int name="rows">100</int>
			<!--  Default search field
          <str name="df">text</str>
          -->
			<!--  Change from JSON to XML format (the default prior to Solr 7.0)
          <str name="wt">xml</str>
          -->
			<!--  Controls the distribution of a query to shards other than itself.
            Consider making 'preferLocalShards' true when:
              1) maxShardsPerNode > 1
              2) Number of shards > 1
              3) CloudSolrClient or LbHttpSolrServer is used by clients.
            Without this option, every core broadcasts the distributed query to
            a replica of each shard where the replicas are chosen randomly.
            This option directs the cores to prefer cores hosted locally, thus
            preventing network delays between machines.
            This behavior also immunizes a bad/slow machine from slowing down all
            the good machines (if those good machines were querying this bad one).

            Specify this option=false for clients connecting through HttpSolrServer
        -->
			<bool name="preferLocalShards">false</bool>
		</lst>
		<!--  In addition to defaults, "appends" params can be specified
         to identify values which should be appended to the list of
         multi-val params from the query (or the existing "defaults").
       -->
		<!--  In this example, the param "fq=instock:true" would be appended to
         any query time fq params the user may specify, as a mechanism for
         partitioning the index, independent of any user selected filtering
         that may also be desired (perhaps as a result of faceted searching).

         NOTE: there is *absolutely* nothing a client can do to prevent these
         "appends" values from being used, so don't use this mechanism
         unless you are sure you always want it.
       -->
		<!-- 
       <lst name="appends">
         <str name="fq">inStock:true</str>
       </lst>
       -->
		<!--  "invariants" are a way of letting the Solr maintainer lock down
         the options available to Solr clients.  Any params values
         specified here are used regardless of what values may be specified
         in either the query, the "defaults", or the "appends" params.

         In this example, the facet.field and facet.query params would
         be fixed, limiting the facets clients can use.  Faceting is
         not turned on by default - but if the client does specify
         facet=true in the request, these are the only facets they
         will be able to see counts for; regardless of what other
         facet.field or facet.query params they may specify.

         NOTE: there is *absolutely* nothing a client can do to prevent these
         "invariants" values from being used, so don't use this mechanism
         unless you are sure you always want it.
       -->
		<!-- 
       <lst name="invariants">
         <str name="facet.field">cat</str>
         <str name="facet.field">manu_exact</str>
         <str name="facet.query">price:[* TO 500]</str>
         <str name="facet.query">price:[500 TO *]</str>
       </lst>
       -->
		<!--  If the default list of SearchComponents is not desired, that
         list can either be overridden completely, or components can be
         prepended or appended to the default list.  (see below)
       -->
		<!-- 
       <arr name="components">
         <str>nameOfCustomComponent1</str>
         <str>nameOfCustomComponent2</str>
       </arr>
       -->
	</requestHandler>
	
	<searchComponent name="suggest" class="solr.SuggestComponent">
	<lst name="suggester">
		<str name="name">myFuzzyLookupSuggester</str>
		<str name="lookupImpl">FuzzyLookupFactory</str>
		<str name="dictionaryImpl">DocumentDictionaryFactory</str>
		<str name="field">ADDRESS_LINE_COPIED</str>
		<!--str name="weightField">ID</str-->
		<str name="suggestAnalyzerFieldType">text_address_line</str>
		<str name="buildOnStartup">true</str>
	</lst>
	<lst name="suggester">
		<str name="name">myAnalyzingInfixLookupSuggester</str>
		<str name="lookupImpl">AnalyzingInfixLookupFactory</str>
		<str name="dictionaryImpl">DocumentDictionaryFactory</str>
		<str name="field">ADDRESS_LINE_COPIED</str>
		<!--str name="weightField">ID</str-->
		<str name="suggestAnalyzerFieldType">text_address_line</str>
		<str name="buildOnStartup">true</str>
	</lst>
	</searchComponent>
	
	<requestHandler name="/suggest" class="solr.SearchHandler" startup="lazy">
		<lst name="defaults">
			<str name="suggest">true</str>
			<str name="suggest.count">30</str>
			<str name="suggest.dictionary">myFuzzyLookupSuggester</str>
			<str name="suggest.dictionary">myAnalyzingInfixLookupSuggester</str>
		</lst>
		<arr name="components">
			<str>suggest</str>
		</arr>
	</requestHandler>

  <searchComponent name="terms" class="solr.TermsComponent"/>

  <!-- A request handler for demonstrating the terms component -->
  <requestHandler name="/terms" class="solr.SearchHandler" startup="lazy">
     <lst name="defaults">
      <bool name="terms">true</bool>
      <bool name="distrib">false</bool>
    </lst>
    <arr name="components">
      <str>terms</str>
    </arr>
  </requestHandler>

  <requestHandler name="/admin/luke" class="org.apache.solr.handler.admin.LukeRequestHandler" />
	
	<!--  A request handler that returns indented JSON by default  -->
	<requestHandler name="/query" class="solr.SearchHandler">
		<lst name="defaults">
			<str name="echoParams">explicit</str>
			<str name="wt">json</str>
			<str name="indent">true</str>
			<str name="df">text</str>
		</lst>
	</requestHandler>
</config>
